#include <bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker,"/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using ull = unsigned long long;
using tlll = tuple<ll,ll,ll>;
using vl = vector<ll>;
using vvl = vector<vl>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if (!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;
}

const ld eps=1e-9;
inline ll diff(ld lhs,ld rhs) {
    if (lhs-eps<rhs && rhs<lhs+eps) {
        return 0;
    }
    return lhs<rhs? -1 : 1;
}

struct Point {
    ld x,y,z;
    bool operator==(const Point &o) const {
        return diff(x,o.x)==0 && diff(y,o.y)==0 && diff(z,o.z)==0;
    }
    Point operator+(const Point& o) const {
        return Point{x+o.x,y+o.y,z+o.z};
    }
    Point operator-(const Point& o) const {
        return Point{x-o.x,y-o.y,z-o.z};
    }
    Point operator*(ld t)const {
        return Point{x*t,y*t,z*t};
    }
    friend istream& operator>>(istream& is, Point& p) {
        return is>>p.x>>p.y>>p.z;
    }
};

inline ld inner(const Point& a,const Point& b) {
    return a.x*b.x + a.y*b.y + a.z*b.z;
}

inline Point outer(const Point& a,const Point& b) {
    return Point{a.y*b.z-b.y*a.z, a.z*b.x-b.z*a.x, a.x*b.y-b.x*a.y};
}

struct Line {
    Point pos,dir;
    Line()=default;
    Line(const Point& a,const Point& b): pos(a),dir(b-a) {}
};

struct Plane {
    Point pos,n;
    Plane()=default;
    Plane(const Point& a,const Point& b,const Point& c) : pos(a),n(outer(b-a,c-a)) {}
};

struct Triangle {
    Point a,b,c;
    vector<Line> l;
    Triangle(const Point& a,const Point& b, const Point& c): a(a),b(b),c(c) {
        Line ab(a,b);
        Line ca(c,a);
        Line bc(b,c);
        l.push_back(ab);
        l.push_back(ca);
        l.push_back(bc);
    }
};

bool is_in_triangle(Point& p, Triangle& t) {
    Point n1 = outer(t.b-t.a,p-t.b);
    Point n2 = outer(t.c-t.b,p-t.c);
    Point n3 = outer(t.a-t.c,p-t.a);

    return diff(inner(n1,n2),0)>0 && diff(inner(n2,n3),0)>0 && diff(inner(n3,n1),0)>0;
}

bool is_on_plane(Point& p,Plane& pl) {
    return diff(inner(p,pl.n),0)==0;
}

Point get_point(Line l,Plane pl) {
    ld t = (inner(pl.pos,pl.n) - inner(l.pos,pl.n)) / inner(l.dir,pl.n);
    return l.pos + l.dir * t;
}

void solve() {
    vector<Point> points(6);
    for (ll i=0;i<6;i++) {
        cin>>points[i];
    }

    ll cnt=0;
    vector<pll> ans;
    for (ll i=1;i<6;i++) {
        for (ll j=i+1;j<6;j++) {
            Triangle t1(points[0],points[i],points[j]);
            Plane pl(points[0],points[i],points[j]);

            vector<ll> left;
            for (ll k=0;k<6;k++) {
                if (k!=0 && k!=i && k!=j) left.push_back(k);
            }
            Triangle t2(points[left[0]],points[left[1]],points[left[2]]);


            for (ll k=0;k<3;k++) {
                Point cur = points[left[k]];

                vector<ll> temp;
                for (ll l=0;l<3;l++) {
                    if (l!=k) temp.push_back(l);
                }

                if (is_on_plane(cur,pl)) {
                    if (is_in_triangle(cur,t1)) {
                        Line l(points[left[temp[0]]],points[left[temp[1]]]);
                        if (diff(inner(l.dir,pl.n),0)==0) continue;
                        if (diff(inner(l.pos-pl.pos,pl.n)*inner(l.pos+l.dir-pl.pos,pl.n),0)>0) continue;
                        Point inter = get_point(l,pl);
                        if (diff(inner(pl.n,points[left[temp[0]]])*inner(pl.n,points[left[temp[1]]]), 0)<0 && ! is_in_triangle(inter,t1)) {
                            ans.push_back({i, j});
                            cnt++;
                            break;
                        }

                        /*if (diff(inner(pl.n,points[left[temp[0]]])*inner(pl.n,points[left[temp[1]]]), 0)<0) {
                            ans.push_back({i, j});
                            cnt++;
                            break;
                        }*/
                    }
                }
            }

            ll ccnt=0;
            for (ll k=0;k<3;k++) {
                Line cur=t2.l[k];
                if (diff(inner(cur.pos-pl.pos,pl.n)*inner(cur.pos+cur.dir-pl.pos,pl.n),0)>0) continue;
                if (diff(inner(cur.dir,pl.n),0)==0) continue;
                Point inter = get_point(cur,pl);
                if (is_in_triangle(inter,t1)) {
                    ccnt++;
                }
            }
            if (ccnt!=1) {
                continue;
            }

            for (ll k=0;k<3;k++) {
                Line cur = t2.l[k];
                if (diff(inner(cur.pos-pl.pos,pl.n)*inner(cur.pos+cur.dir-pl.pos,pl.n),0)>0) continue;
                if (diff(inner(cur.dir,pl.n),0)==0) continue;
                Point inter = get_point(cur,pl);
                if (is_in_triangle(inter,t1)) {
                    ans.push_back({i, j});
                    cnt++;
                    break;
                }
            }
        }
    }


    cout<<cnt<<'\n';
    for (auto [x,y]:ans) {
        cout<<x+1<<" "<<y+1<<'\n';
    }
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    // cin >> t;
    for (ll test=1; test<=t; test++) {
        solve();
    }
    return 0;
}