#include<bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker, "/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using ull = unsigned long long;
using tlll = tuple<ll,ll,ll>;
using vl = vector<ll>;
using vvl = vector<vl>;
using vd = vector<ld>;
using vvd = vector<vd>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if(!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;

}

const ld eps = 1e-9;
inline ll diff(ld lhs, ld rhs) {
    if (lhs-eps<rhs && rhs<lhs+eps) return 0;
    return lhs<rhs ? -1 : 1;
}

struct Point3 {
    ld x, y, z;
    Point3 operator-(const Point3& o) const {
        return Point3{ x-o.x, y-o.y, z-o.z };
    }
    Point3 operator/(const ld& o) const {
        return Point3{ x/o, y/o, z/o };
    }
    friend istream& operator>>(istream& is, Point3& p) {
        return is >> p.x >> p.y >> p.z;
    }
};

struct Point2 {
    ld x, y;
    Point2 operator-(const Point2& o) const {
        return Point2{ x-o.x, y-o.y };
    }
};

inline Point2 to2(const Point3& p) {
    return Point2{ p.x, p.y };
}

inline ld abs(const Point3& p) {
    return sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
}

inline bool is_zero(ld a) {
    return fabsl(a)<eps;
}
ld inverse(vvd&A, vvd&out){
    ll n=A.size();
    ld det=1.0L;
    out.assign(n, vd(n, 0));
    for (ll i=0;i<n;++i) out[i][i]=1;
    for (ll i=0;i<n;++i){
        if (is_zero(A[i][i])){
            ld maxv=0;
            ll maxid=-1;
            for (ll j=i+1;j<n;++j) {
                ld cur=fabsl(A[j][i]);
                if(cur>maxv) {
                    maxv=cur;
                    maxid=j;
                }
            }
            if (maxid<0 || is_zero(A[maxid][i])) return 0;
            for (ll k=0;k<n;++k) {
                A[i][k]+=A[maxid][k];
                out[i][k]+=out[maxid][k];
            }
        }
        det*=A[i][i];
        ld coeff=1.0L/A[i][i];
        for (ll j=0;j<n;++j){
            A[i][j]*=coeff;
            out[i][j]*=coeff;
        }
        for (ll j=0;j<n;++j) {
            if(j==i) continue;
            ld factor=A[j][i];
            for (ll k=0;k<n;++k) {
                A[j][k]-=A[i][k]*factor;
                out[j][k]-=out[i][k]*factor;
            }
        }
    }
    return det;
}

Point3 matrix_vector_multi(const vvd& Ainv, const Point3& point) {
    vd res(3, 0);
    vd p = { point.x, point.y, point.z };
    for (ll i=0; i<3; i++)
        for (ll j=0; j<3; j++)
            res[i] += Ainv[i][j] * p[j];
    return Point3{ res[0], res[1], res[2] };
}

inline ld outer(const Point2& a, const Point2& b) {
    return a.x*b.y-a.y*b.x;
}
inline ll ccw(const Point2& a, const Point2& b, const Point2& c) {
    return diff(outer(b-a, c-a), 0L);
}
bool is_in_polygon(Point2 p, vector<Point2>& poly) {
    ll wn = 0;
    for (ll i=0; i<poly.size(); ++i) {
        ll ni = i+1==poly.size() ? 0 : i+1;
        if (poly[i].y<=p.y) {
            if (poly[ni].y>p.y && ccw(poly[i], poly[ni], p)>0) ++wn;
        }
        else if (poly[ni].y<=p.y && ccw(poly[i], poly[ni], p)<0) --wn;
    }
    return wn != 0;
}

bool isLinked(const vector<Point3>& Points) {
    Point3 P1 = Points[0], P2 = Points[1], P3 = Points[2];
    vector<Point3> other = { Points[3], Points[4], Points[5] };

    // 1. 모든 점에서 P1을 빼줘서 P1이 원점에 오도록 하기
    P2 = P2 - P1;
    P3 = P3 - P1;
    for (auto& e : other)
        e = e - P1;
    P1 = { 0, 0, 0 };

    // 2. 새로운 좌표축이 될 Px, Py 만들기
    Point3 Px = P2/abs(P2), Py = P3/abs(P3);

    // 3. Px, Py로부터 새로운 좌표축 Pz 구하기
    Point3 tmp = { Px.y*Py.z - Px.z*Py.y,
                  Px.z*Py.x - Px.x*Py.z,
                  Px.x*Py.y - Px.y*Py.x};
    Point3 Pz = tmp/abs(tmp);

    // 4. 기저 행렬의 역행렬 구하고 모든 점에 곱해주기
    vvd A = {
        { Px.x, Py.x, Pz.x },
        { Px.y, Py.y, Pz.y },
        { Px.z, Py.z, Pz.z },
    };
    vvd Ainv; inverse(A, Ainv);

    P2 = matrix_vector_multi(Ainv, P2);
    P3 = matrix_vector_multi(Ainv, P3);
    for (auto& e : other)
        e = matrix_vector_multi(Ainv, e);

    // 5. others의 세 점이 삼각형 안에 있는지 판별
    vector<Point2> triangle = { to2(P1), to2(P2), to2(P3) };
    for (ll i=0; i<3; i++) {
        if (diff(other[i].z, 0L)) continue;  // z성분이 0이 아니면 넘기기
        if (is_in_polygon(to2(other[i]), triangle)
            && diff(other[(i+1)%3].z, 0L)
            && diff(other[(i+2)%3].z, 0L)
            && other[(i+1)%3].z*other[(i+2)%3].z < 0) {
            // cout << "case2!!!\n";
            return true;
        }

    }

    // 6. other 삼각형의 선분과 xy 평면의 교점이 삼각형 안에 들어오는 개수 세기
    ll cnt = 0;
    for (ll i=0; i<3; i++) {
        P1 = other[i], P2 = other[(i+1)%3];
        if (!diff(P2.z, P1.z)) continue;
        Point2 point = {
            (-P1.z / (P2.z-P1.z))*(P2.x - P1.x) + P1.x,
            (-P1.z / (P2.z-P1.z))*(P2.y - P1.y) + P1.y,
        };
        if (is_in_polygon(point, triangle)
            && min(P1.x,P2.x)<=point.x
            && point.x<=max(P1.x, P2.x))
            cnt++;
    }
    if (cnt == 1) {
        // cout << "case1!!!\n";
        return true;
    }
    return false;
}

void solve(ll testcase){
    ll i, j, k;
    vector<Point3> P(6); for (auto& e : P) cin >> e;
    cout << (isLinked(P) ? "YES\n" : "NO\n");
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    cin >> t;
    for (ll testcase = 1; testcase <= t; testcase++){
        solve(testcase);
    }
    return 0;
}