#include <bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker,"/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld  = pair<ld,ld>;
using vl = vector<ll>;
using vvl = vector<vl>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if (!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;
}

const ld eps=1e-12;
inline ll diff(ld l, ld r) {
    if (l-eps<r&&r<l+eps) return 0;
    return l<r?-1:1;
}
inline bool not_between(ld ck,ld a,ld b) {
    if (a<b) return ck<a-eps || b+eps<ck;
    return ck<b-eps || a+eps<ck;
}
inline bool is_between(ld ck, ld a, ld b) {
    if (a<b) return a-eps<ck&& ck<b+eps;
    return b-eps<ck && ck<a+eps;
}
struct Point {
    ld x,y;
    bool operator==(const Point &o) const {
        return diff(x,o.x)==0 && diff(y,o.y)==0;
    }
    Point operator+(const Point&o) const {
        return Point{x+o.x,y+o.y};
    }
    Point operator-(const Point&o) const {
        return Point{x-o.x,y-o.y};
    }
    Point operator*(ld t) const {
        return Point{x*t,y*t};
    }
};

inline ld inner(const Point& a,const Point& b) {
    return a.x*b.x+a.y*b.y;
}
inline ld outer(const Point&a,const Point&b) {
    return a.x*b.y - a.y*b.x;
}

struct Line {
    Point pos,dir;
    Line()=default;
    Line(const Point& a,const Point& b) : pos(a),dir(b-a) {}
};
inline ll ccw_line(const Line& line, const Point& point) {
    return diff(outer(line.dir,point-line.pos),0);
}

ll line_seg(const Line& line,const Line& seg,Point& ret) {
    ld mdet = outer(line.dir,seg.dir);
    if (diff(mdet,0)==0) {
        if (ccw_line(line,seg.pos)!=0) return 0;
    }
    ld t1 = -outer(line.pos-seg.pos,line.dir) / mdet;
    if (not_between(t1,0,1)) return 0;
    ret = seg.pos + seg.dir*t1;
    return 1;
}

void solve() {
    ll n;
    cin>>n;
    vector<Line> lines;
    for (ll i=0;i<n;i++) {
        ld x,y;
        cin>>x>>y;
        Point p1(1000*cos(x*numbers::pi/1800),1000*sin(x*numbers::pi/1800));
        Point p2(1000*cos(y*numbers::pi/1800),1000*sin(y*numbers::pi/1800));
        Line l(p1,p2);
        lines.push_back(l);
    }

    ld a1,d1; cin>>a1>>d1;
    ld a2,d2; cin>>a2>>d2;
    Point p1(d1*cos(a1*numbers::pi/1800) , d1*sin(a1*numbers::pi/1800));
    Point p2(d2*cos(a2*numbers::pi/1800) , d2*sin(a2*numbers::pi/1800));
    Line myline(p1,p2);

    ll count=0;
    for (ll i=0;i<n;i++) {
        Point ret;
        if (line_seg(lines[i],myline,ret)==1) {
            count++;
        }
    }
    if (count%2==0) {
        cout<<"YES";
    }
    else {
        cout<<"NO";
    }
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    // cin >> t;
    for (ll test=1; test<=t; test++) {
        solve();
    }
    return 0;
}