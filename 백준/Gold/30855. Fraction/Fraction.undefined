#include <bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker,"/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using vl = vector<ll>;
using vvl = vector<vl>;
using vpll = vector<pll>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if (!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

struct Fraction {
    ll ja, mo;
    Fraction(ll j=0, ll m=1) {
        ja = j;
        mo = m;
        simplify();
    }
    Fraction(Fraction a, Fraction b, Fraction c) {
        Fraction t = a;
        t = t + b / c;
        ja = t.ja;
        mo = t.mo;
    }
    void simplify() {
        ll g = gcd(ja, mo);
        ja /= g;
        mo /= g;
    }
    Fraction operator+(const Fraction &rhs) const {
        return Fraction(ja*rhs.mo + mo*rhs.ja, mo*rhs.mo);
    }
    Fraction operator*(const Fraction &rhs) const {
        return Fraction(ja*rhs.ja, mo*rhs.mo);
    }
    Fraction operator/(const Fraction &rhs) const {
        return Fraction(ja, mo) * Fraction(rhs.mo, rhs.ja);
    }
};

void preprocess() {
    ll i, j, k;
}

Fraction parse(string &s, ll lo, ll hi) {
    if (s[lo] != '(') return Fraction(-1, 1);
    if (s[hi] != ')') return Fraction(-1, 1);
    Fraction a, b, c;
    ll idx = lo+1;

    if (s[idx] == '(') {
        ll cnt = 0;
        for (ll i=idx;i<hi;i++) {
            if (s[i]=='(') cnt++;
            if (s[i]==')') cnt--;
            if (!cnt) {
                a = parse(s, idx, i);
                idx = i+1;
                break;
            }
        }
        if (cnt) return Fraction(-1, 1);
    }
    else if (s[idx] == ')') {
        return Fraction(-1, 1);
    }
    else {
        a = Fraction(s[idx]-'0', 1);
        idx++;
    }

    if (idx>=hi) return Fraction(-1, 1);
    if (s[idx] == '(') {
        ll cnt = 0;
        for (ll i=idx;i<hi;i++) {
            if (s[i]=='(') cnt++;
            if (s[i]==')') cnt--;
            if (!cnt) {
                b = parse(s, idx, i);
                idx = i+1;
                break;
            }
        }
        if (cnt) return Fraction(-1, 1);
    }
    else if (s[idx] == ')') {
        return Fraction(-1, 1);
    }
    else {
        b = Fraction(s[idx]-'0', 1);
        idx++;
    }

    if (idx>=hi) return Fraction(-1, 1);
    if (s[idx] == '(') {
        ll cnt = 0;
        for (ll i=idx;i<hi;i++) {
            if (s[i]=='(') cnt++;
            if (s[i]==')') cnt--;
            if (!cnt) {
                c = parse(s, idx, i);
                idx = i+1;
                break;
            }
        }
        if (cnt) return Fraction(-1, 1);
    }
    else if (s[idx] == ')') {
        return Fraction(-1, 1);
    }
    else {
        c = Fraction(s[idx]-'0', 1);
        idx++;
    }

    if (a.ja==-1 || b.ja==-1 || c.ja==-1) return Fraction(-1, 1);
    return Fraction(a, b, c);
}

void solve(ll test) {
    ll i, j, k;
    ll n; cin>>n;
    cin.ignore();
    string t, s; getline(cin, t);
    for (auto ch: t) if (ch!=' ') s.push_back(ch);
    ll cnt=0;
    for (i=0;i<s.size();i++) {
        if (s[i]=='(') cnt++;
        if (s[i]==')') cnt--;
        if (!cnt) break;
    }
    if (i!=s.size()-1 || cnt) {
        cout<<"-1\n";
        return;
    }
    Fraction f = parse(s, 0, s.size()-1);
    if (f.ja==-1) cout<<"-1\n";
    else cout<<f.ja<<' '<<f.mo<<'\n';
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    // cin >> t;
    for (ll test=1; test<=t; test++) {
        solve(test);
    }
    return 0;
}