#include <bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker,"/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using vl = vector<ll>;
using vvl = vector<vl>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if (!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;
}

struct DSU {
    vl par, sz;
    DSU(ll n) {
        par.resize(n+1);
        sz.assign(n+1, 1);
        iota(par.begin(), par.end(), 0);
    }
    ll _find(ll x) {
        if (par[x]==x) return x;
        return par[x] = _find(par[x]);
    }
    pll _union(ll x, ll y) {
        x = _find(x);
        y = _find(y);
        if (x==y) return {-1, -1};
        if (sz[x] < sz[y]) swap(x, y);
        par[y] = x;
        sz[x] += sz[y];
        return {x, y};  // 부모, 자식
    }
};

void solve(ll test) {
    ll i, j, k;
    ll N, K; cin >> N >> K;

    DSU dsu(N);
    unordered_map<ll,pll> window;   // root 노드, 구간
    ll curIdx = 0, l, r, nxtIdx, nl, nr;
    cin >> l >> r;
    window[curIdx] = { l, r };
    for (nxtIdx=1; nxtIdx<N; nxtIdx++) {
        cin >> nl >> nr;
        if (r < nl) {
            window[nxtIdx] = { nl, nr };
            curIdx = nxtIdx, l = nl, r = nr;
            continue;
        }
        auto [pa,ch] = dsu._union(curIdx, nxtIdx);
        curIdx = pa;
        r = max(r, nr);
        window[curIdx] = { l, r };
        window.erase(ch);
    }

    vector<pll> group;     // 윈도우, root 인덱스
    unordered_map<ll,ll> toNewIdx;
    for (i=0; i<N; i++)
        if (i == dsu._find(i)) {
            group.emplace_back(window[i]);
            toNewIdx[i] = group.size() -1 ;
        }

    vl arr; arr.reserve(group.size());
    arr.emplace_back(0);
    for (i=1; i<group.size(); i++)
        arr.emplace_back(group[i].first - group[i-1].second);

    ll ans = 0;
    for (i=1; i<arr.size(); i++)
        arr[i] += arr[i-1]; // prefix sum
    // sum[l,r] = arr[r] - arr[l-1]
    ll prev = toNewIdx[dsu._find(0)], cur, small, big;
    for (i=0; i<K; i++) {
        cin >> cur;
        cur = toNewIdx[dsu._find(cur-1)];
        if (prev == cur) continue;
        small = min(prev, cur);
        big = max(prev, cur);
        ans += arr[big] - arr[small];
        prev = cur;
    }
    cout << ans;
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    // cin >> t;
    for (ll test=1; test<=t; test++) {
        solve(test);
    }
    return 0;
}