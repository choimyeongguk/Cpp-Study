#include <bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker,"/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using vl = vector<ll>;
using vvl = vector<vl>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if (!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;
}

const ld eps=1e-12;
inline ll diff(ld l, ld r) {
    if (l-eps<r && r<l+eps) return 0;
    return l<r?-1:1;
}
inline bool is_between(ld ck,ld a,ld b) {
    if (a<b) return a-eps<ck && ck<b+eps;
    return b-eps<ck && ck<a+eps;
}
inline bool not_between(ld ck,ld a,ld b) {
    if (a<b) return ck<a-eps || b+eps<ck;
    return ck<b-eps || a+eps<ck;
}
struct Point {
    ld x,y;
    bool operator==(const Point &o) const {
        return diff(x,o.x)==0 && diff(y,o.y)==0;
    }
    Point operator+(const Point &o) const {
        return Point{x+o.x, y+o.y};
    }
    Point operator-(const Point &o) const {
        return Point{x-o.x, y-o.y};
    }
    Point operator*(ld t) const {
        return Point{x*t, y*t};
    }
};
struct Line {
    Point pos,dir;
    Line(const Point&a,const Point&b):pos(a),dir(b-a) {}
};

inline ld inner(const Point&a,const Point&b) {
    return a.x*b.x + a.y*b.y;
}
inline ld outer(const Point&a,const Point&b) {
    return a.x*b.y-a.y*b.x;
}
inline ll ccw_line(const Line&line,const Point& point) {
    return diff(outer(line.dir,point-line.pos),0);
}


ll seg_seg(const Line& a,const Line&b,Point& ret) {
    ld mdet = outer(b.dir,a.dir);
    if (diff(mdet,0)==0) {
        if (ccw_line(a,b.pos)!=0) return 0;
        ld t0=inner(b.pos-a.pos,a.dir) / inner(a.dir,a.dir);
        ld t1 = inner(b.pos+b.dir-a.pos,a.dir) / inner(a.dir,a.dir);
        if (t0>t1) swap(t0,t1);
        ld l=max(0.0L,t0),h=min(1.0L,t1);
        if (diff(h,l)<0) return 0;
        if (diff(h,l)>0) return 2;
        ret = a.pos+a.dir*l;
        return 1;
    }
    ld t1= -outer(b.pos-a.pos,b.dir)/mdet;
    ld t2 = outer(a.dir,b.pos-a.pos)/mdet;
    if (not_between(t1,0,1) || not_between(t2,0,1)) return 0;
    ret = b.pos+b.dir*t2;
    return 1;
}


void solve() {
    Point s1,s3;
    cin>>s1.x>>s1.y>>s3.x>>s3.y;
    Point s2,s4;
    s2 = Point{s1.x,s3.y};
    s4 = Point{s3.x,s1.y};

    vector<Line> lines;
    lines.push_back(Line(s1,s2));
    lines.push_back(Line(s2,s3));
    lines.push_back(Line(s3,s4));
    lines.push_back(Line(s4,s1));

    Point p1,p2;
    cin>>p1.x>>p1.y>>p2.x>>p2.y;
    Line myline(p1,p2);

    for (ll i=0;i<4;i++) {
        Point ret;
        if (seg_seg(lines[i],myline,ret)>=1) {
            cout<<"STOP\n";
            return;
        }
    }

    if (s1.x<= p1.x && p1.x<=s3.x && s1.y<= p1.y && p1.y<=s3.y) {
        if (s1.x<= p2.x && p2.x<=s3.x && s1.y<=p2.y && p2.y<=s3.y) {
            cout<<"STOP\n";return;
        }
    }
    cout<<"OK\n";
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    cin >> t;
    for (ll test=1; test<=t; test++) {
        solve();
    }
    return 0;
}