#include<bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker, "/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = int;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using vb = vector<bool>;
using vl = vector<ll>;
using vvl = vector<vl>;
using vpll = vector<pll>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if(!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;

}

struct FastScanner {
    static const int SZ = 1 << 20;
    int idx, size;
    char buf[SZ];
    FastScanner(): idx(0), size(0) {}
    char read() {
        if (idx >= size) {
            size = (int)fread(buf, 1, SZ, stdin);
            idx = 0;
            if (size == 0) return 0;
        }
        return buf[idx++];
    }
    ll nextInt() {
        char c;
        do c = read(); while (c <= ' ' && c);
        ll sgn = 1;
        if (c == '-') { sgn = -1; c = read(); }
        ll x = 0;
        while (c > ' ') {
            x = x * 10 + (c - '0');
            c = read();
        }
        return x * sgn;
    }
};

const ll MAX = 1'000'000;
vl prime, spf(MAX+1, 0);

void linear_sieve() {
    ll i, j, k;
    for (i=2; i<spf.size(); i++) {
        if (!spf[i]) {
            spf[i] = i;
            prime.emplace_back(i);
        }
        for (auto& p : prime) {
            j = i * p;
            if (j > MAX) break;
            spf[j] = p; // 모든 합성수에 대해 spf는 딱 한번 결정됨 (x = spf * (x/spf)로 유일하게 결정되기 때문)
            if (p == spf[i]) break;
            // p > spf[i]인 경우에 대해,
            // j = i * p 일 때, p와 spf[i]를 교환하여 (i/spf[i]*p) * spf[i] 꼴로 바꾸게 되면
            // j에 대해 p 대신 더 작은 spf를 생각할 수 있으므로, p>spf[i]인 경우에 대해서는 계산하지 않는다.
        }
    }
}

ll pow(ll x, ll y) {
    if (y == 0) return 1;
    if (y == 1) return x;
    ll half = pow(x, y/2);
    if (y & 1) return half * half * x;
    return half * half;
}

ll ipow(ll a, ll e) {
    ll r = 1;
    while (e) {
        if (e & 1) r *= a;
        a *= a;
        e >>= 1;
    }
    return r;
}

FastScanner fs;

void solve(ll testcase){
    ll i, j, k;
    ll N = fs.nextInt(), M = fs.nextInt();
    unordered_map<ll,ll> cnt;
    for (i=0; i<N; i++) {
        ll num = fs.nextInt();
        while (num != 1) {
            ll p = spf[num];
            cnt[p]++;
            num /= p;
        }
    }
    for (i=0; i<M; i++) {
        ll num = fs.nextInt();
        while (num != 1) {
            ll p = spf[num];
            cnt[p]--;
            num /= p;
        }
    }
    ll X=1, Y=1;
    for (auto [k,v] : cnt) {
        if (v > 0) X *= ipow(k, v);
        else if (v < 0) Y *= ipow(k, -v);
    }
    cout << "Case #" << testcase << ": " << X << " / " << Y << "\n";
}

int main() {
    setup();
    preprocess();
    linear_sieve();
    ll t = fs.nextInt();
    for (ll testcase = 1; testcase <= t; testcase++){
        solve(testcase);
    }
    return 0;
}