#include <bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker,"/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using vl = vector<ll>;
using vvl = vector<vl>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if (!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;
}

struct Tarjan {
    ll n, vtime; vl up, visit; vvl graph;
    ll scc_cnt; vl scc_idx;
    stack<ll> stk;
    Tarjan(vvl& g)
        : n(g.size()), vtime(0), up(n), visit(n, 0), graph(g), scc_idx(n, 0), scc_cnt(0) {
        for (ll i=0; i<n; i++) {
            if (visit[i] == 0) dfs4scc(i);
        }
    }
    void dfs4scc(ll node) {
        up[node] = visit[node] = ++vtime;
        stk.emplace(node);
        for (ll next : graph[node]) {
            if (visit[next]==0) {
                dfs4scc(next);
                up[node] = min(up[node], up[next]);
            }
            else if (scc_idx[next] == 0)
                up[node] = min(up[node], visit[next]);
        }
        if (up[node] == visit[node]) {
            ++scc_cnt;
            ll t;
            do {
                t = stk.top(); stk.emplace();
                scc_idx[t] = scc_cnt;
            } while (!stk.empty() && t!= node);
        }
    }
};

void solve() {
    ll i, j, k;
    ll E, V; cin >> E >> V;
    vl G(V, -1);    // G[x]=y := x->y 간선 있다
    vl in_degree(V, 0);
    ll a, b;
    for (i=0; i<E; i++) {
        cin >> a >> b;
        G[a] = b;
        in_degree[b]++;
    }


    vl depth(V, 1);
    vl visit(V, false);
    queue<ll> q;
    for (i=0; i<V; i++)
        if (in_degree[i] == 0)
            q.emplace(i);
    while (!q.empty()) {
        ll cur = q.front(); q.pop();
        visit[cur] = true;

        ll& nxt = G[cur];
        if (nxt == -1) continue;

        depth[nxt] = max(depth[nxt], depth[cur] + 1);
        in_degree[nxt]--;
        if (in_degree[nxt] == 0)
            q.emplace(nxt);
    }

    // for (i=0; i<V; i++) {
    //     cout << i << " : " << depth[i] << "\n";
    // }

    ll ans = 0;
    for (i=0; i<V; i++) {
        if (visit[i]) {
            ans = max(ans, depth[i]);
        }
        else {
            ll node = i, cnt = 0, maxDepth = depth[i];
            do {
                cnt++;
                maxDepth = max(maxDepth, depth[node]);
                visit[node] = true;
                node = G[node];
            } while (node != i);
            ans = max(ans, maxDepth + cnt - 1);
        }
    }
    cout << ans;

    // ll E, V; cin >> E >> V;
    // vvl G(V);
    // ll a, b;
    // for (i=0; i<E; i++) {
    //     cin >> a >> b;
    //     G[a].emplace_back(b);
    // }
    // Tarjan SCC(G);
    // vl& scc_idx = SCC.scc_idx;
    //
    // ll CN = SCC.scc_cnt;
    // vvl CG(CN+1);
    // vl numNode(CN+1, 0);
    // vl in_degree(CN+1, 0);
    // for (i=0; i<V; i++) {   // from
    //     numNode[scc_idx[i]]++;  // 각 연결요소에 들어있는 노드 개수
    //     for (j=0; j<G[i].size(); j++) { // to
    //         if (scc_idx[i] == scc_idx[G[i][j]]) continue;
    //         // cout << scc_idx[i] << " 와 " << scc_idx[j] << " 연결함!!\n";
    //         CG[scc_idx[i]].emplace_back(scc_idx[G[i][j]]);
    //         in_degree[scc_idx[G[i][j]]]++;
    //     }
    // }
    // // for (i=1; i<=CN; i++) {
    // //     cout << i << " : ";
    // //     for (auto& e : CG[i])
    // //         cout << e << " ";
    // //     cout << "\n";
    // // }
    //
    // queue<ll> q;
    // for (i=1; i<=CN; i++)
    //     if (in_degree[i] == 0)
    //         q.emplace(i);
    // vl depth(CN+1, 1);
    // while (!q.empty()) {
    //     ll cur = q.front(); q.pop();
    //     for (auto& nxt : CG[cur]) {
    //         depth[nxt] = max(depth[nxt], depth[cur] + 1);
    //         in_degree[nxt]--;
    //         if (in_degree[nxt] == 0)
    //             q.emplace(nxt);
    //     }
    // }
    //
    // // for (i=1; i<=CN; i++)
    // //     cout << numNode[i] << " ";
    // // cout << "scc_cnt : " << SCC.scc_cnt << "\n";
    // // for (i=0; i<V; i++) {
    // //     cout << scc_idx[i] << " ";
    // // }
    // // cout << "\n";
    // // for (i=1; i<=CN; i++) {
    // //     cout << i << " : ";
    // //     for (auto& e : CG[i])
    // //         cout << e << " ";
    // //     cout << "\n";
    // // }
    //
    // ll ans = 0;
    // for (i=1; i<=CN; i++) {
    //     ans = max(ans, depth[i] + numNode[i] - 1);
    // }
    // cout << ans;
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    // cin >> t;
    for (ll test=1; test<=t; test++) {
        solve();
    }
    return 0;
}