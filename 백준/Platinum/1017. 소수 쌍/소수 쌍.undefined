#include<bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker, "/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using ull = unsigned long long;
using tlll = tuple<ll,ll,ll>;
using vl = vector<ll>;
using vvl = vector<vl>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if(!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;

}

ll modmul(ll a, ll b, ll m) {
    return ll((__int128)a*(__int128)b%m);
}

ll modpow(ll n, ll k, ll m) {
    ll ret=1;
    n%=m;
    while (k) {
        if (k&1) ret=ret*n%m;
        n=n*n%m;
        k>>=1;
    }
    return ret;
}

bool is_prime(ll n) {
    if (n<2 || n%2==0 || n%3==0) return n==2 || n==3;
    ll k=__builtin_ctzll(n-1), d=n-1>>k;
    for (ll a: { 2, 325, 9375, 28178, 450775, 9780504, 1795265022 }) {
        ll p=modpow(a%n, d, n), i=k;
        while (p!=1 && p!=n-1 && a%n && i--) p = modmul(p, p, n);
        if (p!=n-1 && i!=k) return 0;
    }
    return 1;
}

struct BipartiteGraph {
    ll n; vl color; vvl adj;
    bool is_bipartite = true;
    ll leftSz, rightSz;
    vl leftNodes, rightNodes;   // partition idx → original idx
    vl leftId, rightId;         // original idx → partition idx
    vvl adjL;                   // left index → [right indices...]
    // maximum matching
    ll matching, distNil, INF = 1e10;
    vl pairL, pairR, dist;

    // 엣지를 바로 입력
    BipartiteGraph(ll L, ll R)
        : leftSz(L), rightSz(R), adjL(L) {}

    void add_edge(ll l, ll r) {
        adjL[l].emplace_back(r);
    }
    void erase_edge(ll ln, ll rn) {
        ll l = leftId[ln], r = rightId[rn];
        adjL[l].erase(lower_bound(adjL[l].begin(), adjL[l].end(), r));
    }

    // 일반 그래프 → 이분 그래프 변환
    BipartiteGraph(const vvl& G)
      : n(G.size()), adj(G), color(n, 0)
    {
        for (ll i=0; i<n; ++i) {    // 0-based index
            if (color[i] == 0 && !bfs_color(i)) {
                is_bipartite = false;
                return;
            }
        }
        build_bipartite();     // 좌우 파티션 노드 분리, 매핑, 인접 리스트 생성
    }

    bool bfs_color(ll s) {
        queue<ll> q;
        color[s] = 1;
        q.push(s);
        while (!q.empty()) {
            ll node = q.front(); q.pop();
            for (auto& nxt : adj[node]) {
                if (color[nxt] == 0) {
                    color[nxt] = -color[node];
                    q.push(nxt);
                } else if (color[nxt] == color[node])
                    return false;
            }
        }
        return true;
    }

    void build_bipartite() {
        leftId.assign(n, -1);
        rightId.assign(n, -1);
        for (ll i=0; i<n; ++i) {
            if (color[i] == 1) {
                leftId[i] = leftNodes.size();
                leftNodes.push_back(i);
            } else {
                rightId[i] = rightNodes.size();
                rightNodes.push_back(i);
            }
        }
        leftSz = leftNodes.size();
        rightSz = rightNodes.size();
        adjL.assign(leftSz, {});
        for (ll l=0; l<leftSz; ++l) {
            for (auto& r : adj[leftNodes[l]])
                adjL[l].emplace_back(rightId[r]);
            sort(adjL[l].begin(), adjL[l].end());
        }
    }

    // maximum matching: Hopcroft-Karp
    ll max_matching() {
        matching = 0;
        pairL.assign(leftSz, -1);
        pairR.assign(rightSz, -1);
        dist.assign(leftSz, 0);
        while (bfs_HK())
            for (ll l=0; l<leftSz; ++l)
                if (pairL[l]==-1 && dfs_HK(l))
                    matching++;
        return matching;
    }

    bool bfs_HK() {
        queue<ll> q;
        for (ll l=0; l<leftSz; l++) {
            if (pairL[l] == -1) {
                dist[l] = 0;
                q.emplace(l);
            } else dist[l] = INF;
        }
        distNil = INF;
        while (!q.empty()) {
            ll l = q.front(); q.pop();
            if (dist[l] < distNil) {
                for (auto& r : adjL[l]) {
                    ll pl = pairR[r];
                    if (pl != -1) {
                        if (dist[pl] == INF) {
                            dist[pl] = dist[l] + 1;
                            q.emplace(pl);
                        }
                    } else distNil = dist[l] + 1;
                }
            }
        }
        return distNil != INF;
    }

    bool dfs_HK(ll l) {
        for (ll r : adjL[l]) {
            ll pl = pairR[r];
            if (pl==-1 || (dist[pl]==dist[l]+1 && dfs_HK(pl))) {
                pairL[l] = r;
                pairR[r] = l;
                return true;
            }
        }
        dist[l] = INF;
        return false;
    }
};

void solve(ll testcase){
    ll i, j, k;
    ll N; cin >> N;
    vl arr(N); for (auto& e : arr) cin >> e;
    vvl G(N);
    for (i=0; i<N; i++) {
        for (j=i+1; j<N; j++) {
            if (is_prime(arr[i]+arr[j])) {
                G[i].emplace_back(j);
                G[j].emplace_back(i);
            }
        }
    }
    BipartiteGraph bt(G);
    vl ans;
    while (bt.max_matching() == N/2) {
        ll pair = bt.rightNodes[bt.pairL[bt.leftId[0]]];
        ans.emplace_back(arr[pair]);
        bt.erase_edge(0, pair);
    }
    sort(ans.begin(), ans.end());
    if (ans.empty()) cout << -1;
    else for (auto& e : ans) cout << e << " ";
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    // cin >> t;
    for (ll testcase = 1; testcase <= t; testcase++){
        solve(testcase);
    }
    return 0;
}