#include<bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker, "/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using ull = unsigned long long;
using tlll = tuple<ll,ll,ll>;
using vl = vector<ll>;
using vvl = vector<vl>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if(!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;

}

struct MCMF {
    struct Edge { ll nxt, rev, res, cost; };
    ll n;
    vector<vector<Edge>> g;
    MCMF(ll n): n(n), g(n) {}

    void add_edge(ll s, ll e, ll cap, ll cost, ll rev_cap = 0){
        g[s].emplace_back(e, (ll)g[e].size(), cap, cost);
        g[e].emplace_back(s, (ll)g[s].size()-1, rev_cap, -cost);
    }

    // s->t로 최대 maxf만큼 보냄(기본: 무한). (flow, cost) 반환
    pll min_cost_max_flow(ll src, ll sink, ll maxf = LLONG_MAX){
        const ll INF = LLONG_MAX;
        ll flow = 0, minCost = 0;

        vl pi(n, 0), dist(n), avail(n);
        vl pv(n), pe(n);    // prev vertex, prev edge idx

        // 초기 포텐셜: 음수비용 간선이 있을 수 있으면 SPFA/BF로 한 번 계산
        auto spfa_init = [&](){
            deque<ll> dq; vector<bool> inq(n,false);
            fill(pi.begin(), pi.end(), INF);
            pi[src] = 0; dq.push_back(src); inq[src] = true;
            while (!dq.empty()){
                ll cur = dq.front(); dq.pop_front(); inq[cur] = false;
                for (auto& [nxt,rev,res,cost] : g[cur])
                    if (res>0 && pi[nxt]>pi[cur]+cost) {
                        pi[nxt] = pi[cur] + cost;
                        if (!inq[nxt]) {
                            inq[nxt] = true;
                            if (!dq.empty() && pi[nxt]<pi[dq.front()]) dq.push_front(nxt);
                            else dq.push_back(nxt);
                        }
                }
            }
            for (ll i=0; i<n; i++)
                if (pi[i] == INF) pi[i] = 0; // 도달불가는 0으로
        };
        spfa_init();

        while (flow < maxf){
            fill(dist.begin(), dist.end(), INF);
            fill(avail.begin(), avail.end(), 0);
            dist[src] = 0; avail[src] = INF;
            priority_queue<pll,vector<pll>,greater<pll>> pq;
            pq.emplace(0, src);
            while (!pq.empty()){
                auto [d,cur] = pq.top(); pq.pop();
                if (d != dist[cur]) continue;
                for (ll i=0; i<g[cur].size(); i++) {
                    auto& [nxt,rev,res,cost] = g[cur][i];
                    if (res <= 0) continue;
                    ll w = cost + pi[cur] - pi[nxt]; // 감소비용
                    if (dist[nxt] > dist[cur]+w){
                        dist[nxt] = dist[cur] + w;
                        pv[nxt] = cur; pe[nxt] = i;
                        avail[nxt] = min(avail[cur], res);
                        pq.push({dist[nxt], nxt});
                    }
                }
            }
            if(dist[sink] == INF) break; // 더 이상 증가경로 없음
            for(ll i=0; i<n; i++)
                if(dist[i] < INF) pi[i] += dist[i]; // 포텐셜 업데이트
            ll add = min(avail[sink], maxf-flow);
            flow += add;
            for (ll i=sink; i!=src; i=pv[i]) {
                auto& [nxt,rev,res,cost] = g[pv[i]][pe[i]];
                res -= add;
                g[i][rev].res += add;
                minCost += add*cost;
            }
        }
        return {flow, minCost};
    }
};

void solve(ll testcase){
    ll i, j, k;
    vvl value = {
        { 10, 8, 7, 5, 1 },
        {  8, 6, 4, 3, 1 },
        {  7, 4, 3, 2, 1 },
        {  5, 3, 2, 2, 1 },
        {  1, 1, 1, 1, 0 },
    };
    ll R, C; cin >> R >> C;
    vvl table(R, vl(C));
    char c;
    for (auto& e : table)
        for (auto& v : e) {
            cin >> c;
            v = c=='F' ? 4 : c-'A';
        }

    ll id = 0;
    vvl loc2id(R, vl(C));
    for (auto& e : loc2id)
        for (auto& v : e)
            v = id++;

    MCMF flow(2*R*C + 2);
    ll RC = R*C;
    auto v_in = [&](ll node) { return node; };
    auto v_out = [&](ll node) { return node+RC; };
    ll src = 2*R*C, sink = src+1, INF = 1e10;
    // 정점용량
    for (i=0; i<RC; i++)
        flow.add_edge(v_in(i), v_out(i), 1, 0);
    // src -> 홀수칸
    for (i=0; i<R; i++)
        for (j=i&1?1:0; j<C; j+=2)
            flow.add_edge(src, v_in(loc2id[i][j]), 1, 0);
    // 모든칸 -> sink
    for (i=0; i<R; i++)
        for (j=0; j<C; j++)
            flow.add_edge(v_out(loc2id[i][j]), sink, 1, 0);
    // 홀수칸 -> 짝수칸
    ll nr, nc;
    vvl d = {{-1, 0, 1, 0},{0, 1, 0, -1}};
    for (i=0; i<R; i++) {
        for (j=i&1?1:0; j<C; j+=2) {
            for (k=0; k<4; k++) {
                nr = i + d[0][k];
                nc = j + d[1][k];
                if (nr<0 || nc<0 || nr==R || nc==C) continue;
                flow.add_edge(v_out(loc2id[i][j]), v_in(loc2id[nr][nc]),
                    1, -value[table[i][j]][table[nr][nc]]);
            }
        }
    }
    pll ans = flow.min_cost_max_flow(src, sink);
    cout << -ans.second;
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    // cin >> t;
    for (ll testcase = 1; testcase <= t; testcase++){
        solve(testcase);
    }
    return 0;
}