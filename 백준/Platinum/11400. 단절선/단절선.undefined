#include<bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker, "/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using ull = unsigned long long;
using tlll = tuple<ll,ll,ll>;
using vl = vector<ll>;
using vvl = vector<vl>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if(!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;

}

struct Tarjan {
    ll n, vtime; vl up, visit; vvl graph;
    ll scc_cnt; vl scc_idx, stk;    // for scc
    vl cutVertex;                   // for cutVertex
    vector<pll> cutEdge;            // for bridges, (u, v) with u < v
    // for biconnected component
    stack<pll> estk;                // DFS 중 쌓는 간선 스택
    vector<vector<pll>> bcc_edges;  // 각 BCC를 이루는 간선들
    vector<vector<ll>>  bcc_nodes;  // 각 BCC에 속한 정점들(중복 제거됨)

    Tarjan (vvl& g)
        : n(g.size()), vtime(0), up(n), visit(n,0), graph(g),
          scc_idx(n,0), scc_cnt(0)
    {
        for (ll i=0;i<n;++i)
            // if (visit[i] == 0) dfs4scc(i);
            if (visit[i] == 0) dfs4tarjan(i, -1);
        sort(cutVertex.begin(), cutVertex.end());
        sort(cutEdge.begin(), cutEdge.end());
        // build_bcc_nodes();
        // 동시에 여러개 쓰고 싶으면 알아서 vtime, visit, up 초기화 하기
    }

    void dfs4scc(ll node){
        up[node] = visit[node] = ++vtime;
        stk.push_back(node);
        for (ll next : graph[node]){
            if (visit[next] == 0) {
                dfs4scc(next);
                up[node] = min(up[node], up[next]);
            }
            else if (scc_idx[next] == 0)
                up[node] = min(up[node], visit[next]);
        }
        if (up[node]==visit[node]){
            ++scc_cnt;
            ll t;
            do {
                t = stk.back(); stk.pop_back();
                scc_idx[t] = scc_cnt;
            } while (!stk.empty() && t != node);
        }
    }

    void dfs4tarjan(ll node, ll parent){
        bool isCutVertex = false;
        ll childNum = 0;
        up[node] = visit[node] = ++vtime;
        bool skippedParentEdge = false; // multiEdge 고려
        for (auto& nxt : graph[node]){
            if (nxt == parent && !skippedParentEdge) { skippedParentEdge = true; continue; }
            if (visit[nxt] == 0) {
                childNum++;
                /* for BCC
                 * estk.emplace(node, nxt);
                 */
                dfs4tarjan(nxt, node);
                up[node] = min(up[node], up[nxt]);
                if (up[nxt] >= visit[node]) {
                    if (parent != -1) isCutVertex = true;
                    /* // for BCC
                     * vector<pll> compE;
                     * while (true) {
                     *     auto e = estk.top(); estk.pop();
                     *     compE.emplace_back(e);
                     *     if (e.first==node && e.second==nxt) break;
                     * }
                     * bcc_edges.emplace_back(move(compE));
                     */
                }
                 // for curEdge(bridge) bridge 구할 때 필요없는 건 알아서 지우셈
                 if (up[nxt] > visit[node]) {
                     cutEdge.emplace_back(node<nxt ?
                         pll{node, nxt} : pll{nxt, node});
                 } else up[node] = min(up[node], visit[nxt]);
            } else {
                up[node] = min(up[node], visit[nxt]);
                /* // for BCC
                 * estk.emplace(node, nxt);
                 */
            }
        }
        if (parent == -1 && childNum > 1) isCutVertex = true;
        if (isCutVertex) cutVertex.emplace_back(node);
    }

    void build_bcc_nodes_from_edges(){
        bcc_nodes.clear();
        bcc_nodes.reserve(bcc_edges.size());
        for (auto &compE : bcc_edges){
            vector<ll> verts;
            verts.reserve(compE.size() * 2);
            for (auto &e : compE) {
                verts.push_back(e.first);
                verts.push_back(e.second);
            }
            sort(verts.begin(), verts.end());
            verts.erase(unique(verts.begin(), verts.end()), verts.end());
            bcc_nodes.push_back(move(verts));
        }
    }
};

void solve(ll testcase){
    ll i, j, k;
    ll V, E; cin >> V >> E;
    vvl graph(V+1);
    ll a, b;
    for (i=0; i<E; i++) {
        cin >> a >> b;
        graph[a].emplace_back(b);
        graph[b].emplace_back(a);
    }
    Tarjan tarjan(graph);
    cout << tarjan.cutEdge.size() << "\n";
    for (auto& [f,s] : tarjan.cutEdge) {
        cout << f << " " << s << "\n";
    }
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    // cin >> t;
    for (ll testcase = 1; testcase <= t; testcase++){
        solve(testcase);
    }
    return 0;
}