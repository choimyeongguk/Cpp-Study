#include<bits/stdc++.h>
#pragma warning(disable:4996)
#pragma comment(linker, "/STACK:336777216")
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx,avx2,fma")
using namespace std;
using ll = long long;
using pll = pair<ll,ll>;
using ld = long double;
using pld = pair<ld,ld>;
using ull = unsigned long long;
using tlll = tuple<ll,ll,ll>;
using vl = vector<ll>;
using vvl = vector<vl>;

#ifdef ONLINE_JUDGE
constexpr bool ndebug = true;
#else
constexpr bool ndebug = false;
#endif

void setup() {
    if(!ndebug) {
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    }
    else {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);
    }
}

void preprocess() {
    ll i, j, k;

}

struct BipartiteGraph {
    ll n; vl color; vvl adj;
    bool is_bipartite = true;
    ll leftSz, rightSz;
    vl leftNodes, rightNodes;   // partition idx → original idx
    vl leftId, rightId;         // original idx → partition idx
    vvl adjL;                   // left index → [right indices...]
    // maximum matching
    ll matching, distNil, INF = 1e10;
    vl pairL, pairR, dist;

    // 엣지를 바로 입력
    BipartiteGraph(ll L, ll R)
        : leftSz(L), rightSz(R), adjL(L) {}

    void add_edge(ll l, ll r) {
        adjL[l].emplace_back(r);
    }

    // 일반 그래프 → 이분 그래프 변환
    BipartiteGraph(const vvl& G)
      : n(G.size()), adj(G), color(n, 0)
    {
        for (ll i=0; i<n; ++i) {    // 0-based index
            if (color[i] == 0 && !bfs_color(i)) {
                is_bipartite = false;
                return;
            }
        }
        build_bipartite();     // 좌우 파티션 노드 분리, 매핑, 인접 리스트 생성
    }

    bool bfs_color(ll s) {
        queue<ll> q;
        color[s] = 1;
        q.push(s);
        while (!q.empty()) {
            ll node = q.front(); q.pop();
            for (auto& nxt : adj[node]) {
                if (color[nxt] == 0) {
                    color[nxt] = -color[node];
                    q.push(nxt);
                } else if (color[nxt] == color[node])
                    return false;
            }
        }
        return true;
    }

    void build_bipartite() {
        leftId.assign(n, -1);
        rightId.assign(n, -1);
        for (ll i=0; i<n; ++i) {
            if (color[i] == 1) {
                leftId[i] = leftNodes.size();
                leftNodes.push_back(i);
            } else {
                rightId[i] = rightNodes.size();
                rightNodes.push_back(i);
            }
        }
        leftSz = leftNodes.size();
        rightSz = rightNodes.size();
        adjL.assign(leftSz, {});
        for (ll l=0; l<leftSz; ++l)
            for (auto& r : adj[leftNodes[l]])
                adjL[l].emplace_back(rightId[r]);
    }

    // maximum matching: Hopcroft-Karp
    ll max_matching() {
        matching = 0;
        pairL.assign(leftSz, -1);
        pairR.assign(rightSz, -1);
        dist.assign(leftSz, 0);
        while (bfs_HK())
            for (ll l=0; l<leftSz; ++l)
                if (pairL[l]==-1 && dfs_HK(l))
                    matching++;
        return matching;
    }

    bool bfs_HK() {
        queue<ll> q;
        for (ll l=0; l<leftSz; l++) {
            if (pairL[l] == -1) {
                dist[l] = 0;
                q.emplace(l);
            } else dist[l] = INF;
        }
        distNil = INF;
        while (!q.empty()) {
            ll l = q.front(); q.pop();
            if (dist[l] < distNil) {
                for (auto& r : adjL[l]) {
                    ll pl = pairR[r];
                    if (pl != -1) {
                        if (dist[pl] == INF) {
                            dist[pl] = dist[l] + 1;
                            q.emplace(pl);
                        }
                    } else distNil = dist[l] + 1;
                }
            }
        }
        return distNil != INF;
    }

    bool dfs_HK(ll l) {
        for (ll r : adjL[l]) {
            ll pl = pairR[r];
            if (pl==-1 || (dist[pl]==dist[l]+1 && dfs_HK(pl))) {
                pairL[l] = r;
                pairR[r] = l;
                return true;
            }
        }
        dist[l] = INF;
        return false;
    }
};


void solve(ll testcase){
    ll i, j, k;
    // 입력
    ll N, M; cin >> N >> M;
    vvl board(N, vl(N, true));
    while (M--) {
        cin >> i >> j;
        board[i-1][j-1] = false;
    }

    // 대각선 인덱스 지정
    ll idx1 = -1, idx2 = -1;
    ll r, c;
    vvl diagonal1(N, vl(N, -1));    // 좌상->우하
    vvl diagonal2(N, vl(N, -1));    // 우상->좌하
    for (i=0; i<N; i++) {
        for (j=0; j<N; j++) {
            if (!board[i][j]) continue;
            if (diagonal1[i][j] == -1) {
                r = i, c = j, idx1++;
                while (r<N && c<N && board[r][c])
                    diagonal1[r++][c++] = idx1;
            }
            if (diagonal2[i][j] == -1) {
                r = i, c = j, idx2++;
                while (r<N && c>=0 && board[r][c])
                    diagonal2[r++][c--] = idx2;
            }
        }
    }

    // 그래프 생성
    BipartiteGraph bg(idx1+1, idx2+1);
    for (i=0; i<N; i++) {
        for (j=0; j<N; j++) {
            if (!board[i][j]) continue;
            bg.add_edge(diagonal1[i][j], diagonal2[i][j]);
            bg.add_edge(diagonal1[i][j], diagonal2[i][j]);
        }
    }
    cout << bg.max_matching();
}

int main() {
    setup();
    preprocess();
    ll t = 1;
    // cin >> t;
    for (ll testcase = 1; testcase <= t; testcase++){
        solve(testcase);
    }
    return 0;
}